#include "Nemesys.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCParser/MCAsmLexer.h"
#include "llvm/MC/MCParser/MCAsmParser.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/TargetRegistry.h"

using namespace llvm;

// Auto-generated by TableGen
static unsigned MatchRegisterName(StringRef Name);

namespace {

struct NemesysOperand;

class NemesysAsmParser : public MCTargetAsmParser {
  std::unique_ptr<NemesysOperand> parseRegister();

  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &Operands) override;

  bool MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                               OperandVector &Operands, MCStreamer &Out,
                               uint64_t &ErrorInfo,
                               bool MatchingInlineAsm) override;

  bool ParseRegister(unsigned &RegNum, SMLoc &StartLoc,
                     SMLoc &EndLoc) override {
    llvm_unreachable("Implement nemesys ParseRegister");
  }

  bool ParseDirective(AsmToken DirectiveID) override {
    llvm_unreachable("Implement nemesys ParseDirective");
  }

// Auto-generated instruction matching functions
#define GET_ASSEMBLER_HEADER
#include "NemesysGenAsmMatcher.inc"

  OperandMatchResultTy parseOperand(OperandVector *Operands,
                                    StringRef Mnemonic);

public:
  NemesysAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
                   const MCInstrInfo &MII, const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser),
        Lexer(Parser.getLexer()), SubtargetInfo(STI) {
    setAvailableFeatures(
        ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
  }

private:
  MCAsmParser &Parser;
  MCAsmLexer &Lexer;

  const MCSubtargetInfo &SubtargetInfo;
};

struct NemesysOperand : public MCParsedAsmOperand {
  enum KindTy { TOKEN, REGISTER } Kind;

  struct Token {
    const char *Data;
    unsigned Length;
  };

  struct RegOp {
    unsigned RegNum;
  };

  union {
    struct Token Tok;
    struct RegOp Reg;
  };

  explicit NemesysOperand(KindTy Kind) : MCParsedAsmOperand(), Kind(Kind) {}
  SMLoc StartLoc, EndLoc;

public:
  SMLoc getStartLoc() const override { return StartLoc; }

  SMLoc getEndLoc() const override { return EndLoc; }

  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  StringRef getToken() const {
    assert(isToken() && "Invalid type access!");
    return StringRef(Tok.Data, Tok.Length);
  }

  unsigned getReg() const override {
    assert(isReg() && "Invalid type access!");
    return Reg.RegNum;
  }

  bool isToken() const override { return Kind == TOKEN; }

  bool isReg() const override { return Kind == REGISTER; }

  bool isImm() const override { return false; }

  bool isMem() const override { return false; }

  void print(raw_ostream &OS) const override {
    OS << "Reg: %r" << getReg() << "\n";
  }

  static std::unique_ptr<NemesysOperand> CreateToken(StringRef Str,
                                                     SMLoc Start) {
    auto Op = make_unique<NemesysOperand>(TOKEN);
    Op->Tok.Data = Str.data();
    Op->Tok.Length = Str.size();
    Op->StartLoc = Start;
    Op->EndLoc = Start;
    return Op;
  }

  static std::unique_ptr<NemesysOperand> createReg(unsigned RegNum, SMLoc Start,
                                                   SMLoc End) {
    auto Op = make_unique<NemesysOperand>(REGISTER);
    Op->Reg.RegNum = RegNum;
    Op->StartLoc = Start;
    Op->EndLoc = End;
    return Op;
  }
};

} // namespace

OperandMatchResultTy NemesysAsmParser::parseOperand(OperandVector *Operands,
                                                    StringRef Mnemonic) {
  // Attempt to parse token as register
  std::unique_ptr<NemesysOperand> Op = parseRegister();

  if (!Op) {
    Error(Parser.getTok().getLoc(), "Unknown operand");
    Parser.eatToEndOfStatement();
    return MatchOperand_ParseFail;
  }

  Operands->push_back(std::move(Op));

  return MatchOperand_Success;
}

bool NemesysAsmParser::ParseInstruction(ParseInstructionInfo & /*Info*/,
                                        StringRef Name, SMLoc NameLoc,
                                        OperandVector &Operands) {
  StringRef Mnemonic = Name;
  Operands.push_back(NemesysOperand::CreateToken(Mnemonic, NameLoc));

  // If there are no more operands, then finish
  if (Lexer.is(AsmToken::EndOfStatement))
    return false;

  // Parse first operand
  if (parseOperand(&Operands, Mnemonic) != MatchOperand_Success)
    return true;

  // Parse until end of statement, consuming commas between operands
  while (parseOptionalToken(AsmToken::Comma))
    if (parseOperand(&Operands, Mnemonic) != MatchOperand_Success)
      return true;

  return false;
}

std::unique_ptr<NemesysOperand> NemesysAsmParser::parseRegister() {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  if (Lexer.getKind() == AsmToken::Identifier) {
    if (auto RegNum = MatchRegisterName(Lexer.getTok().getIdentifier())) {
      Parser.Lex(); // Eat identifier token
      return NemesysOperand::createReg(RegNum, Start, End);
    }
  }
  return nullptr;
}

bool NemesysAsmParser::MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                                               OperandVector &Operands,
                                               MCStreamer &Out,
                                               uint64_t &ErrorInfo,
                                               bool MatchingInlineAsm) {
  MCInst Inst;
  SMLoc ErrorLoc;

  switch (MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm)) {
  case Match_Success:
    Out.EmitInstruction(Inst, SubtargetInfo);
    Opcode = Inst.getOpcode();
    return false;
  case Match_MissingFeature:
    return Error(IdLoc, "Instruction use requires option to be enabled");
  case Match_MnemonicFail:
    return Error(IdLoc, "Unrecognized instruction mnemonic");
  case Match_InvalidOperand: {
    ErrorLoc = IdLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo >= Operands.size())
        return Error(IdLoc, "Too few operands for instruction");

      ErrorLoc = ((NemesysOperand &)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc())
        ErrorLoc = IdLoc;
    }
    return Error(ErrorLoc, "Invalid operand for instruction");
  }
  default:
    break;
  }

  llvm_unreachable("Unknown match type detected!");
}

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include "NemesysGenAsmMatcher.inc"

extern "C" void LLVMInitializeNemesysAsmParser() {
  RegisterMCAsmParser<NemesysAsmParser> x(getTheNemesysTarget());
}
