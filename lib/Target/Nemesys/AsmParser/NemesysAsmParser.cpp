#include "MCTargetDesc/NemesysBaseInfo.h"
#include "Nemesys.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCParser/MCAsmLexer.h"
#include "llvm/MC/MCParser/MCAsmParser.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/TargetRegistry.h"
#include <map>

#define DEBUG_TYPE "asm-parser"

using namespace llvm;

// Auto-generated by TableGen
static unsigned MatchRegisterName(StringRef Name);

namespace {

struct NemesysOperand;

class NemesysAsmParser : public MCTargetAsmParser {
  std::unique_ptr<NemesysOperand> parseRegister();
  std::unique_ptr<NemesysOperand> parseImmediate();

  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &Operands) override;

  bool MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                               OperandVector &Operands, MCStreamer &Out,
                               uint64_t &ErrorInfo,
                               bool MatchingInlineAsm) override;

  struct NearMissMessage {
    SMLoc Loc;
    SmallString<128> Message;
  };

  bool ReportNearMisses(SmallVectorImpl<NearMissInfo> &NearMisses, SMLoc IdLoc,
                        OperandVector &Operands);

  void FilterNearMisses(SmallVectorImpl<NearMissInfo> &NearMissesIn,
                        SmallVectorImpl<NearMissMessage> &NearMissesOut,
                        SMLoc IdLoc, OperandVector &Operands);

  bool ParseRegister(unsigned &RegNum, SMLoc &StartLoc,
                     SMLoc &EndLoc) override {
    llvm_unreachable("Implement nemesys ParseRegister");
  }

  bool ParseDirective(AsmToken DirectiveID) override {
    llvm_unreachable("Implement nemesys ParseDirective");
  }

// Auto-generated instruction matching functions
#define GET_ASSEMBLER_HEADER
#include "NemesysGenAsmMatcher.inc"

  OperandMatchResultTy parseOperand(OperandVector *Operands,
                                    StringRef Mnemonic);
  OperandMatchResultTy parsePCRel16(OperandVector &);
  OperandMatchResultTy parseCondCode(OperandVector &, StringRef, SMLoc);

public:
  enum NemesysMatchResultTy {
    Match_Dummy = FIRST_TARGET_MATCH_RESULT_TY,
#define GET_OPERAND_DIAGNOSTIC_TYPES
#include "NemesysGenAsmMatcher.inc"

  };

  NemesysAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
                   const MCInstrInfo &MII, const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser),
        Lexer(Parser.getLexer()), SubtargetInfo(STI) {
    setAvailableFeatures(
        ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
  }

private:
  MCAsmParser &Parser;
  MCAsmLexer &Lexer;

  const MCSubtargetInfo &SubtargetInfo;
};

struct NemesysOperand : public MCParsedAsmOperand {
  enum KindTy { TOKEN, REGISTER, IMMEDIATE, CONDCODE } Kind;

  struct Token {
    const char *Data;
    unsigned Length;
  };

  struct RegOp {
    unsigned RegNum;
  };

  struct ImmOp {
    const MCExpr *Value;
  };

  union {
    struct Token Tok;
    struct RegOp Reg;
    struct ImmOp Imm;
    unsigned CC;
  };

  explicit NemesysOperand(KindTy Kind) : MCParsedAsmOperand(), Kind(Kind) {}
  SMLoc StartLoc, EndLoc;

public:
  SMLoc getStartLoc() const override { return StartLoc; }

  SMLoc getEndLoc() const override { return EndLoc; }

  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    addExpr(Inst, getImm());
  }

  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
    // Add as immediate when possible.  Null MCExpr = 0.
    if (!Expr)
      Inst.addOperand(MCOperand::createImm(0));
    else if (const MCConstantExpr *CE = dyn_cast<MCConstantExpr>(Expr))
      Inst.addOperand(MCOperand::createImm(CE->getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

  void addCondCodeOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    Inst.addOperand(MCOperand::createImm(getCC()));
  }

  StringRef getToken() const {
    assert(isToken() && "Invalid type access!");
    return StringRef(Tok.Data, Tok.Length);
  }

  unsigned getReg() const override {
    assert(isReg() && "Invalid type access!");
    return Reg.RegNum;
  }

  const MCExpr *getImm() const {
    assert(isImm() && "Invalid type access!");
    return Imm.Value;
  }

  unsigned getCC() const {
    assert(isCondCode() && "Invalid type access!");
    return CC;
  }

  bool isToken() const override { return Kind == TOKEN; }

  bool isReg() const override { return Kind == REGISTER; }

  bool isImm() const override { return Kind == IMMEDIATE; }

  bool isImmSExt6() const {
    if (Kind != IMMEDIATE)
      return false;
    if (const auto *MCE = dyn_cast<MCConstantExpr>(Imm.Value))
      return isInt<6>(MCE->getValue());
    return false;
  }

  bool isImmSExt16() const {
    if (Kind != IMMEDIATE)
      return false;
    if (const auto *MCE = dyn_cast<MCConstantExpr>(Imm.Value))
      return isInt<16>(MCE->getValue());
    return false;
  }

  bool isCondCode() const { return Kind == CONDCODE; }

  bool isMem() const override { return false; }

  void print(raw_ostream &OS) const override {
    switch (Kind) {
    case TOKEN:
      OS << "'" << getToken() << "'";
      break;
    case REGISTER:
      OS << "Reg: r" << getReg();
      break;
    case IMMEDIATE:
      OS << "Imm: " << *getImm();
      break;
    case CONDCODE:
      OS << "CC " << getCC();
      break;
    }
  }

  static std::unique_ptr<NemesysOperand> CreateToken(StringRef Str,
                                                     SMLoc Start) {
    auto Op = make_unique<NemesysOperand>(TOKEN);
    Op->Tok.Data = Str.data();
    Op->Tok.Length = Str.size();
    Op->StartLoc = Start;
    Op->EndLoc = Start;
    return Op;
  }

  static std::unique_ptr<NemesysOperand> createReg(unsigned RegNum, SMLoc Start,
                                                   SMLoc End) {
    auto Op = make_unique<NemesysOperand>(REGISTER);
    Op->Reg.RegNum = RegNum;
    Op->StartLoc = Start;
    Op->EndLoc = End;
    return Op;
  }

  static std::unique_ptr<NemesysOperand> createImm(const MCExpr *Val,
                                                   SMLoc Start, SMLoc End) {
    auto Op = make_unique<NemesysOperand>(IMMEDIATE);
    Op->Imm.Value = Val;
    Op->StartLoc = Start;
    Op->EndLoc = End;
    return Op;
  }

  static std::unique_ptr<NemesysOperand>
  createCondCode(const unsigned CC, SMLoc Start, SMLoc End) {
    auto Op = make_unique<NemesysOperand>(CONDCODE);
    Op->CC = CC;
    Op->StartLoc = Start;
    Op->EndLoc = End;
    return Op;
  }
};

} // namespace

OperandMatchResultTy NemesysAsmParser::parseOperand(OperandVector *Operands,
                                                    StringRef Mnemonic) {
  // Check if the current operand has a custom associated parser, if so, try to
  // custom parse the operand, or fallback to the general approach.
  OperandMatchResultTy Result = MatchOperandParserImpl(*Operands, Mnemonic);

  if (Result == MatchOperand_Success)
    return Result;
  if (Result == MatchOperand_ParseFail) {
    Parser.eatToEndOfStatement();
    return Result;
  }
  // Attempt to parse token as register
  std::unique_ptr<NemesysOperand> Op = parseRegister();

  if (!Op)
    Op = parseImmediate();

  if (!Op) {
    Error(Parser.getTok().getLoc(), "unknown operand");
    Parser.eatToEndOfStatement();
    return MatchOperand_ParseFail;
  }

  Operands->push_back(std::move(Op));

  return MatchOperand_Success;
}

bool NemesysAsmParser::ParseInstruction(ParseInstructionInfo & /*Info*/,
                                        StringRef Name, SMLoc NameLoc,
                                        OperandVector &Operands) {
  std::pair<StringRef, StringRef> MnemonicTail = Name.split('.');
  StringRef Mnemonic = MnemonicTail.first, Suffix = MnemonicTail.second;
  Operands.push_back(NemesysOperand::CreateToken(Mnemonic, NameLoc));

  // Parse optional condition code
  if (!MnemonicTail.second.empty()) {
    SMLoc SuffixLoc =
        SMLoc::getFromPointer(NameLoc.getPointer() + Mnemonic.size() + 1);
    if (parseCondCode(Operands, Suffix, SuffixLoc) == MatchOperand_ParseFail)
      return true;
  }

  // If there are no more operands, then finish
  if (Lexer.is(AsmToken::EndOfStatement))
    return false;

  // Parse first operand
  if (parseOperand(&Operands, Mnemonic) != MatchOperand_Success)
    return true;

  // Parse until end of statement, consuming commas between operands
  while (parseOptionalToken(AsmToken::Comma))
    if (parseOperand(&Operands, Mnemonic) != MatchOperand_Success)
      return true;

  return false;
}

std::unique_ptr<NemesysOperand> NemesysAsmParser::parseRegister() {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  if (Lexer.getKind() == AsmToken::Identifier) {
    if (auto RegNum = MatchRegisterName(Lexer.getTok().getIdentifier())) {
      Parser.Lex(); // Eat identifier token
      return NemesysOperand::createReg(RegNum, Start, End);
    }
  }
  return nullptr;
}

std::unique_ptr<NemesysOperand> NemesysAsmParser::parseImmediate() {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  if (!parseOptionalToken(AsmToken::Hash))
    return nullptr;

  const MCExpr *Val;
  if (Lexer.getKind() == AsmToken::Integer && !Parser.parseExpression(Val))
    return NemesysOperand::createImm(Val, Start, End);

  return nullptr;
}

OperandMatchResultTy NemesysAsmParser::parsePCRel16(OperandVector &Operands) {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  if (!parseOptionalToken(AsmToken::Hash))
    return MatchOperand_NoMatch;

  const MCExpr *Val;
  if (Parser.parseExpression(Val))
    return MatchOperand_ParseFail;

  Operands.push_back(NemesysOperand::createImm(Val, Start, End));
  return MatchOperand_Success;
}

OperandMatchResultTy NemesysAsmParser::parseCondCode(OperandVector &Operands,
                                                     StringRef Tail,
                                                     SMLoc SuffixLoc) {
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  auto CCIt = std::find_if(CondCodeStrs.begin(), CondCodeStrs.end(),
                           [Tail](const std::pair<CondCode, const char *> &P) {
                             return Tail == P.second;
                           });

  if (CCIt != CondCodeStrs.end()) {
    Operands.push_back(
        NemesysOperand::createCondCode(CCIt->first, SuffixLoc, End));
    return MatchOperand_Success;
  }

  Error(SuffixLoc, "unknown condition code");
  Parser.eatToEndOfStatement();
  return MatchOperand_ParseFail;
}

bool NemesysAsmParser::MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                                               OperandVector &Operands,
                                               MCStreamer &Out,
                                               uint64_t &ErrorInfo,
                                               bool MatchingInlineAsm) {
  MCInst Inst;
  SMLoc ErrorLoc;
  SmallVector<NearMissInfo, 4> NearMisses;

  switch (
      MatchInstructionImpl(Operands, Inst, &NearMisses, MatchingInlineAsm)) {
  case Match_Success:
    Out.EmitInstruction(Inst, SubtargetInfo);
    Opcode = Inst.getOpcode();
    return false;
  case Match_MissingFeature:
    return Error(IdLoc, "Instruction use requires option to be enabled");
  case Match_MnemonicFail:
    return Error(IdLoc, "Unrecognized instruction mnemonic");
  case Match_NearMisses:
    return ReportNearMisses(NearMisses, IdLoc, Operands);
  case Match_InvalidOperand: {
    ErrorLoc = IdLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo >= Operands.size())
        return Error(IdLoc, "Too few operands for instruction");

      ErrorLoc = ((NemesysOperand &)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc())
        ErrorLoc = IdLoc;
    }
    return Error(ErrorLoc, "Invalid operand for instruction");
  }
  default:
    break;
  }

  llvm_unreachable("Unknown match type detected!");
}

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include "NemesysGenAsmMatcher.inc"

void NemesysAsmParser::FilterNearMisses(
    SmallVectorImpl<NearMissInfo> &NearMissesIn,
    SmallVectorImpl<NearMissMessage> &NearMissesOut, SMLoc IdLoc,
    OperandVector &Operands) {
  // Record some information about near-misses that we have already seen, so
  // that we can avoid reporting redundant ones. For example, if there are
  // variants of an instruction that take 8- and 16-bit immediates, we want
  // to only report the widest one.
  std::multimap<unsigned, unsigned> OperandMissesSeen;
  SmallSet<uint64_t, 4> FeatureMissesSeen;

  // Process the near-misses in reverse order, so that we see more general ones
  // first, and so can avoid emitting more specific ones.
  for (NearMissInfo &I : reverse(NearMissesIn)) {
    switch (I.getKind()) {
    case NearMissInfo::NearMissOperand: {
      SMLoc OperandLoc =
          ((NemesysOperand &)*Operands[I.getOperandIndex()]).getStartLoc();
      const char *OperandDiag =
          getMatchKindDiag((NemesysMatchResultTy)I.getOperandError());

      // If we have already emitted a message for a superclass, don't also
      // report the sub-class. We consider all operand classes that we don't
      // have a specialised diagnostic for to be equal for the propose of this
      // check, so that we don't report the generic error multiple times on the
      // same operand.
      unsigned DupCheckMatchClass = OperandDiag ? I.getOperandClass() : ~0U;
      auto PrevReports = OperandMissesSeen.equal_range(I.getOperandIndex());
      if (std::any_of(
              PrevReports.first, PrevReports.second,
              [DupCheckMatchClass](const std::pair<unsigned, unsigned> Pair) {
                if (DupCheckMatchClass == ~0U || Pair.second == ~0U)
                  return Pair.second == DupCheckMatchClass;
                else
                  return isSubclass((MatchClassKind)DupCheckMatchClass,
                                    (MatchClassKind)Pair.second);
              }))
        break;
      OperandMissesSeen.insert(
          std::make_pair(I.getOperandIndex(), DupCheckMatchClass));

      NearMissMessage Message;
      Message.Loc = OperandLoc;
      if (OperandDiag) {
        Message.Message = OperandDiag;
      } else if (I.getOperandClass() == InvalidMatchClass) {
        Message.Message = "too many operands for instruction";
      } else {
        Message.Message = "invalid operand for instruction";
        DEBUG(dbgs() << "Missing diagnostic string for operand class "
                     << getMatchClassName((MatchClassKind)I.getOperandClass())
                     << I.getOperandClass() << ", error " << I.getOperandError()
                     << ", opcode " << MII.getName(I.getOpcode()) << "\n");
      }
      NearMissesOut.emplace_back(Message);
      break;
    }
    case NearMissInfo::NearMissFeature:
    case NearMissInfo::NearMissPredicate:
      break;
    case NearMissInfo::NearMissTooFewOperands: {
      SMLoc EndLoc = ((NemesysOperand &)*Operands.back()).getEndLoc();
      NearMissesOut.emplace_back(NearMissMessage{
          EndLoc, StringRef("too few operands for instruction")});
      break;
    }
    case NearMissInfo::NoNearMiss:
      // This should never leave the matcher.
      llvm_unreachable("not a near-miss");
      break;
    }
  }
}

bool NemesysAsmParser::ReportNearMisses(
    SmallVectorImpl<NearMissInfo> &NearMisses, SMLoc IdLoc,
    OperandVector &Operands) {
  SmallVector<NearMissMessage, 4> Messages;
  FilterNearMisses(NearMisses, Messages, IdLoc, Operands);

  if (Messages.size() == 0) {
    // No near-misses were found, so the best we can do is "invalid
    // instruction".
    return Error(IdLoc, "invalid instruction");
  } else if (Messages.size() == 1) {
    // One near miss was found, report it as the sole error.
    return Error(Messages[0].Loc, Messages[0].Message);
  } else {
    // More than one near miss, so report a generic "invalid instruction"
    // error, followed by notes for each of the near-misses.
    Error(IdLoc, "invalid instruction, any of the following would fix this:");
    for (auto &M : Messages) {
      Note(M.Loc, M.Message);
    }
    return true;
  }
}

extern "C" void LLVMInitializeNemesysAsmParser() {
  RegisterMCAsmParser<NemesysAsmParser> x(getTheNemesysTarget());
}
